/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package ex_7_8

import java.io.IOException
import java.io.Serializable


sealed class Result<out A>: Serializable {
    abstract fun <B> map(f: (A)->B): Result<B>
    abstract fun <B> flatMap(f:(A)->Result<B>): Result <B>
    abstract fun mapFailure(message:String): Result<A>

    fun filter(p:(A)-> Boolean): Result<A> =
        flatMap {
            if (p(it))  this
            else failure("Condition not matched")
        }

    fun filter(message: String, p: (A)-> Boolean): Result<A> =
        flatMap {
            if (p(it)) this
            else failure(message)
        }

    fun exists(p: (A) -> Boolean): Boolean = map(p).getOrElse(false)



    fun getOrElse(defaultValue: @UnsafeVariance A): A = when (this) {
        is Success -> this.value
        else -> defaultValue
    }

    fun getOrElse(defaultValue:()->@UnsafeVariance A) : A = when
                                                                    (this) {
        is Success ->this.value
        else -> defaultValue()
    }

    fun  orElse(defaultValue: ()->Result<@UnsafeVariance A>) =
        when (this) {
            is Success -> this
            else -> try {
                defaultValue()
            }catch (e:RuntimeException) {
                Result.failure<A>(e)
            }catch (e:Exception) {
                Result.failure<A>(RuntimeException(e))
            }
        }

    internal object Empty: Result<Nothing>(){
        override fun mapFailure(message: String) : Result<Nothing> = this
        override fun <B> map(f: (Nothing)->B): Result<B> = Empty
        override fun <B> flatMap(f:(Nothing)->Result<B>) : Result<B> = Empty
        override fun toString(): String = "Empty"
    }

    internal class Failure<out A>(internal val exception: RuntimeException): Result<A>() {
        override fun mapFailure(message: String): Result <A> =
            Failure(RuntimeException(message,exception))

        override fun <B> map(f:(A)->B): Result<B> = Failure(exception)
        override fun <B> flatMap(f:(A)->Result<B>) : Result<B> = Failure(exception)


        override fun toString(): String="Failure (${exception.message})"
    }

    internal class Success<out A> (internal val value: A) : Result<A>() {
        override fun mapFailure(message: String) : Result<A> = this
        override fun <B> map(f: (A) -> B): Result<B> =
            try {
                Success(f(value))
            } catch (e:RuntimeException) {
                Failure(e)
            } catch (e: Exception) {
                Failure(RuntimeException(e))
            }

        override fun <B>    flatMap (f:(A)->Result<B>): Result<B> =
            try {
                f(value)
            } catch (e: RuntimeException) {
                Failure(e)
            } catch (e:Exception) {
                Failure (RuntimeException (e))
            }
        override fun toString():String="Success($value)"
    }

    companion object {
        operator fun <A> invoke(a: A? = null): Result<A> = when (a) {
            null -> Failure(NullPointerException())
            else -> Success(a)
        }
        operator fun <A> invoke (): Result<A> = Empty
        fun <A> failure(message : String) :             Result<A> =  Failure(IllegalStateException(message))
        fun <A> failure (exception: RuntimeException):  Result<A> = Failure(exception)
        fun <A> failure (exception: Exception):         Result<A> =  Failure(IllegalStateException(exception))

        operator fun <A> invoke (a:A? = null, message: String): Result<A> =
            when (a)   {
                null -> Failure(NullPointerException(message))
                else -> Success(a)
            }
        operator fun <A> invoke (a: A? = null, p:(A) -> Boolean) : Result<A> =
            when (a)    {
                null -> failure(NullPointerException())
                else -> when {
                    p(a) -> Success(a)
                    else -> Empty
                }
            }

        operator fun <A> invoke (a:A? = null, message: String, p:(A) -> Boolean): Result<A> =
            when (a) {
                null -> Failure(NullPointerException())
                else -> when {
                    p(a) -> Success(a)
                    else -> Failure(IllegalArgumentException("Argument $a does not match condition: $message"))
                }
            }

    }
}


class App {
    val greeting: String
        get() {
            return "Hello World!"
        }
}

fun main() {
    println(App().greeting)
    var testNull : Int? = null
    val resultNull=Result(testNull,"I have nothing more than null")
    println(resultNull)

    var testInt:Int?=10
    val resultInt=Result(testInt,{it>10})
    println(resultInt)

    var testArgument: Int?=100
    val resultArgument=Result(testArgument,"argument >99",{it<100})
    println(resultArgument)
}
